---
title: 编译器警告 C4200 - C4399
description: Microsoft C/c + + 编译器警告的表 C4200 通过 C4389。
ms.date: 10/18/2020
f1_keywords:
- C4203
- C4277
- C4279
- C4298
- C4299
- C4301
- C4303
- C4314
- C4315
- C4317
- C4318
- C4321
- C4322
- C4323
- C4327
- C4328
- C4330
- C4338
- C4352
- C4362
- C4367
- C4370
- C4380
- C4387
ms.openlocfilehash: 5b0b910c358db57af044471218f9d63ca128e658
ms.sourcegitcommit: f19f02f217b80804ab321d463c76ce6f681abcc6
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/19/2020
ms.locfileid: "92176025"
---
# <a name="compiler-warnings-c4200-through-c4399"></a>编译器警告 C4200 到 C4399

文档的本节中的文章介绍了编译器生成的一小部分警告消息。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="warning-messages"></a>警告消息

|警告|Message|
|-------------|-------------|
|[编译器警告（等级 2 和 4）C4200](../../error-messages/compiler-warnings/compiler-warning-levels-2-and-4-c4200.md)|使用了非标准扩展：结构/联合中的零大小数组|
|[编译器警告（等级 4）C4201](../../error-messages/compiler-warnings/compiler-warning-level-4-c4201.md)|使用了非标准扩展：无号结构/联合|
|[编译器警告（等级 4）C4202](../../error-messages/compiler-warnings/compiler-warning-level-4-c4202.md)|使用了非标准扩展： "..."：名称列表中的原型参数非法|
|编译器警告 C4203|使用了非标准扩展：带静态成员变量的联合|
|[编译器警告（等级 4）C4204](../../error-messages/compiler-warnings/compiler-warning-level-4-c4204.md)|使用了非标准扩展：非常量聚合初始值设定项|
|[编译器警告（等级 4）C4205](../../error-messages/compiler-warnings/compiler-warning-level-4-c4205.md)|使用了非标准扩展：函数范围内的静态函数声明|
|[编译器警告（等级 4）C4206](../../error-messages/compiler-warnings/compiler-warning-level-4-c4206.md)|使用了非标准扩展：翻译单元为空|
|[编译器警告（等级 4）C4207](../../error-messages/compiler-warnings/compiler-warning-level-4-c4207.md)|使用了非标准扩展：扩展初始值设定项窗体|
|[编译器警告（等级 4）C4208](../../error-messages/compiler-warnings/compiler-warning-level-4-c4208.md)|使用了非标准扩展： delete [exp]-计算但忽略 exp|
|[编译器警告（等级 4）C4210](../../error-messages/compiler-warnings/compiler-warning-level-4-c4210.md)|使用了非标准扩展：函数给定文件范围|
|[编译器警告（等级 4）C4211](../../error-messages/compiler-warnings/compiler-warning-level-4-c4211.md)|使用了非标准扩展：将 extern 重定义为 static|
|[编译器警告（等级 4）C4212](../../error-messages/compiler-warnings/compiler-warning-level-4-c4212.md)|使用了非标准扩展：函数声明使用了省略号|
|[编译器警告（等级 4）C4213](../../error-messages/compiler-warnings/compiler-warning-level-4-c4213.md)|使用了非标准扩展：左值上的强制转换|
|[编译器警告（等级 4）C4214](../../error-messages/compiler-warnings/compiler-warning-level-4-c4214.md)|使用了非标准扩展： int 以外的位域类型|
|[编译器警告（等级 1）C4215](../../error-messages/compiler-warnings/compiler-warning-level-1-c4215.md)|使用了非标准扩展：长浮点|
|[编译器警告（等级 1）C4216](../../error-messages/compiler-warnings/compiler-warning-level-1-c4216.md)|使用了非标准扩展：长浮点|
|[编译器警告（等级 1）C4218](../../error-messages/compiler-warnings/compiler-warning-level-1-c4218.md)|使用了非标准扩展：必须至少指定一个存储类或一个类型|
|[编译器警告（等级 4）C4220](../../error-messages/compiler-warnings/compiler-warning-level-4-c4220.md)|varargs 与剩余的参数匹配|
|[编译器警告（等级 4）C4221](../../error-messages/compiler-warnings/compiler-warning-level-4-c4221.md)|使用了非标准扩展： "*identifier*"：无法使用自动变量 "*variable*" 的地址初始化|
|[编译器警告（等级 1 和 4）C4223](../../error-messages/compiler-warnings/compiler-warning-levels-1-and-4-c4223.md)|使用了非标准扩展：将非 lvalue 数组转换为指针|
|[编译器警告（等级 1）C4224](../../error-messages/compiler-warnings/compiler-warning-level-1-c4224.md)|使用了非标准扩展：形参 "*identifier*" 以前被定义为类型|
|[编译器警告 (等级1，错误) C4226](../../error-messages/compiler-warnings/compiler-warning-level-1-c4226.md)|使用了非标准扩展： "*关键字*" 是过时的关键字|
|[编译器警告（等级 1）C4227](../../error-messages/compiler-warnings/compiler-warning-level-1-c4227.md)|使用了记时错误：忽略引用上的限定符|
|[编译器警告（等级 1）C4228](../../error-messages/compiler-warnings/compiler-warning-level-1-c4228.md)|使用了非标准扩展：忽略声明符列表中逗号后面的限定符|
|[编译器警告（等级 1）C4229](../../error-messages/compiler-warnings/compiler-warning-level-1-c4229.md)|使用了记时错误：忽略数据上的修饰符|
|[编译器警告（等级 1）C4230](../../error-messages/compiler-warnings/compiler-warning-level-1-c4230.md)|使用了记时错误：修饰符/限定符交错;已忽略限定符|
|[编译器警告（等级 4）C4232](../../error-messages/compiler-warnings/compiler-warning-level-4-c4232.md)|使用了非标准扩展： "*identifier*"： dllimport "*dllimport*" 的地址不是静态的，不保证标识|
|[编译器警告 (级别4，错误) C4233](../../error-messages/compiler-warnings/compiler-warning-level-4-c4233.md)|使用了非标准扩展：仅在 c + + 中*支持关键字关键字*，而不支持 c|
|[编译器警告 (级别4，错误) C4234](../../error-messages/compiler-warnings/compiler-warning-level-4-c4234.md)|使用了非标准扩展：保留 "*关键字*" 关键字供将来使用|
|[编译器警告 (级别4，错误) C4235](../../error-messages/compiler-warnings/compiler-warning-level-4-c4235.md)|使用了非标准扩展：此体系结构不支持*关键字 "关键字"*|
|[编译器警告（等级 1）C4237](../../error-messages/compiler-warnings/compiler-warning-level-1-c4237.md)|"*关键字*" 关键字目前尚不受支持，但保留以供将来使用|
|[编译器警告（等级 4）C4238](../../error-messages/compiler-warnings/compiler-warning-level-4-c4238.md)|使用了非标准扩展：类 rvalue 用作了 lvalue|
|[编译器警告（等级 4）C4239](../../error-messages/compiler-warnings/compiler-warning-level-4-c4239.md)|使用了非标准扩展： "*token*"：从 "*type1*" 转换为 "*type2*"|
|[编译器警告（等级 3）C4240](../../error-messages/compiler-warnings/compiler-warning-level-3-c4240.md)|使用了非标准扩展：对 "*classname*" 的访问现已定义为 "*access_specifier1*"，以前它被定义为 "*access_specifier2*"|
|[编译器警告（等级 4）C4242](../../error-messages/compiler-warnings/compiler-warning-level-4-c4242.md)|"*identifier*"：从 "*type1*" 转换到 "*type2*"，可能丢失数据|
|[编译器警告（等级 3）C4243](../../error-messages/compiler-warnings/compiler-warning-level-3-c4243.md)|"*conversion_type*" 从 "*type1*" 到 "*type2*" 的转换存在，但不可访问|
|[编译器警告（等级 2）C4244](../../error-messages/compiler-warnings/compiler-warning-level-2-c4244.md)|"*conversion_type*"：从 "*type1*" 转换到 "*type2*"，可能丢失数据|
|[编译器警告（等级 3 和 4）C4244](../../error-messages/compiler-warnings/compiler-warning-levels-3-and-4-c4244.md)|"*conversion_type*"：从 "*type1*" 转换到 "*type2*"，可能丢失数据|
|[编译器警告（等级 4）C4245](../../error-messages/compiler-warnings/compiler-warning-level-4-c4245.md)|"*conversion_type*"：从 "*type1*" 转换为 "*type2*"，有符号/无符号不匹配|
|[编译器警告（等级 2）C4250](../../error-messages/compiler-warnings/compiler-warning-level-2-c4250.md)|"*classname*"：通过控制继承 "*base_classname*：：*member*"|
|[编译器警告（等级 1）C4251](../../error-messages/compiler-warnings/compiler-warning-level-1-c4251.md)|"*identifier*"： "*object_type1*" "*identifier1*" 需要有 dll 接口，由 "*object_type*" "*identfier2*" 的客户端使用|
|[编译器警告（等级 4）C4254](../../error-messages/compiler-warnings/compiler-warning-level-4-c4254.md)|"*operator*"：从 "*type1*：*field_bits*" 转换为 "*type2*：*field_bits*"，可能丢失数据|
|[编译器警告（等级 4）C4255](../../error-messages/compiler-warnings/compiler-warning-level-4-c4255.md)|"*function*"：未给出函数原型：将 " ( # A1" 转换为 " (void) "|
|[编译器警告（等级 4）C4256](../../error-messages/compiler-warnings/compiler-warning-level-4-c4256.md)|"*function*"：具有虚拟基的类的构造函数具有 "...";调用可能与较旧版本的 Visual C++ 不兼容|
|[编译器警告（等级 1）C4258](../../error-messages/compiler-warnings/compiler-warning-level-1-c4258.md)|"*variable*"：忽略 for 循环中的定义;使用封闭范围中的定义|
|[编译器警告（等级 4）C4263](../../error-messages/compiler-warnings/compiler-warning-level-4-c4263.md)|"*function*"：成员函数不重写任何基类虚拟成员函数|
|[编译器警告（等级 1）C4264](../../error-messages/compiler-warnings/compiler-warning-level-1-c4264.md)|"*virtual_function*"：不能重写基 "*classname*" 中的虚拟成员函数;函数被隐藏|
|[编译器警告（等级 3）C4265](../../error-messages/compiler-warnings/compiler-warning-level-3-c4265.md)|"*classname*"：类有虚函数，但析构函数不 virtual\n 此类的实例可能不能正确销毁|
|[编译器警告（等级 4）C4266](../../error-messages/compiler-warnings/compiler-warning-level-4-c4266.md)|"*virtual_function*"：不能重写基 "*classname*" 中的虚拟成员函数;函数被隐藏|
|[编译器警告（等级 3）C4267](../../error-messages/compiler-warnings/compiler-warning-level-3-c4267.md)|"*variable*"：从 "size_t" 转换为 "*type*"，可能丢失数据|
|[编译器警告（等级 4）C4268](../../error-messages/compiler-warnings/compiler-warning-level-4-c4268.md)|"*identifier*"：用编译器生成的默认构造函数初始化的 "const" 静态/全局数据用零填充对象|
|[编译器警告（等级 1）C4269](../../error-messages/compiler-warnings/compiler-warning-level-1-c4269.md)|"*identifier*"：用编译器生成的默认构造函数初始化的 "const" 自动数据产生不可靠的结果|
|[编译器警告（等级 1）C4272](../../error-messages/compiler-warnings/compiler-warning-level-1-c4272.md)|"*function*"：标记为 __declspec (dllimport) ;导入函数时必须指定本机调用约定。|
|[编译器警告（等级 1）C4273](../../error-messages/compiler-warnings/compiler-warning-level-1-c4273.md)|"*function*"： dll 链接不一致|
|[编译器警告（等级 1）C4274](compiler-warning-level-1-c4274.md)|#ident 忽略，则为;请参阅 #pragma 注释的文档 " (exestr" 的 "string" ) |
|[编译器警告（等级 2）C4275](../../error-messages/compiler-warnings/compiler-warning-level-2-c4275.md)|非 dll 接口 "*classkey*" "*identifier1*" 用作 dll 接口 "*classkey*" "*identifier2*" 的基|
|[编译器警告（等级 1）C4276](../../error-messages/compiler-warnings/compiler-warning-level-1-c4276.md)|"*function*"：未提供原型;假定没有参数|
|编译器警告 (等级 1) C4277|导入项 "*classname*：：*member*" 同时作为数据成员和函数成员存在;已忽略数据成员|
|[编译器警告（等级 3）C4278](../../error-messages/compiler-warnings/compiler-warning-level-3-c4278.md)|"*identifier*"：类型库 "*库*" 中的标识符已经是宏;使用 "重命名" 限定符|
|编译器警告 (等级3和级别 4) C4279|"*identifier*"：类型库 "*库*" 中的标识符是关键字;使用 "重命名" 限定符|
|[编译器警告（等级 3）C4280](../../error-messages/compiler-warnings/compiler-warning-level-3-c4280.md)|"operator->" 通过类型 "*type*" 自行递归|
|[编译器警告（等级 3）C4281](../../error-messages/compiler-warnings/compiler-warning-level-3-c4281.md)|"operator->" 通过类型 "*type1*" 发生递归|
|[编译器警告（等级 3）C4282](../../error-messages/compiler-warnings/compiler-warning-level-3-c4282.md)|然后通过类型 "*type2*"|
|[编译器警告（等级 3）C4283](../../error-messages/compiler-warnings/compiler-warning-level-3-c4283.md)|并通过类型 "*typeN*"|
|[编译器警告（等级 2）C4285](../../error-messages/compiler-warnings/compiler-warning-level-2-c4285.md)|如果使用中缀表示法应用，则 "*identifier*：： operator->" 的返回类型为递归|
|[编译器警告（等级 1）C4286](../../error-messages/compiler-warnings/compiler-warning-level-1-c4286.md)|"*derived_type*"：在行 "*line_number*" 上由基类 ( "*base_type*" ) 捕获|
|[编译器警告（等级 3）C4287](../../error-messages/compiler-warnings/compiler-warning-level-3-c4287.md)|"*operator*"：无符号/负常量不匹配|
|[编译器警告（等级 1）C4288](../../error-messages/compiler-warnings/compiler-warning-level-1-c4288.md)|使用了非标准扩展： "*variable*"：在 for 循环中声明的循环控制变量用在了 for 循环范围外;它与外部范围内的声明冲突|
|[编译器警告（等级 4）C4289](../../error-messages/compiler-warnings/compiler-warning-level-4-c4289.md)|使用了非标准扩展： "*variable*"：在 for 循环中声明的循环控制变量用在了 for 循环范围之外|
|[编译器警告（等级 3）C4290](../../error-messages/compiler-warnings/compiler-warning-level-3-c4290.md)|已忽略 c + + 异常规范，但指示函数不 __declspec (nothrow) |
|[编译器警告（等级 1）C4291](../../error-messages/compiler-warnings/compiler-warning-level-1-c4291.md)|"*声明*"：未找到匹配的运算符删除;如果初始化引发异常，则不会释放内存|
|[编译器警告（等级 1）C4293](../../error-messages/compiler-warnings/compiler-warning-level-1-c4293.md)|"*shift_operator*"： shift 计数为负或过大，未定义行为|
|[编译器警告（等级 4）C4295](../../error-messages/compiler-warnings/compiler-warning-level-4-c4295.md)|"*array*"：数组太小，无法包括终止 null 字符|
|[编译器警告（等级 4）C4296](../../error-messages/compiler-warnings/compiler-warning-level-4-c4296.md)|"*operator*"： expression 始终为 "*boolean_value*"|
|[编译器警告（等级 1）C4297](../../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md)|"*function*"：假定函数不引发异常，而是|
|编译器警告 (等级 4) C4298|"*identifier*"：类型库 "*库*" 中的标识符已经是宏;重命名为 "*__identifier*"|
|编译器警告 (等级 4) C4299|"*identifier*"：类型库 "*库*" 中的标识符是关键字;重命名为 "*__identifier*"|
|编译器警告 C4301|"*derived_class*：：*function*"：重写虚函数只与 const/volatile 限定符的 "*base_class*：：*function*" 不同|
|[编译器警告（等级 2）C4302](../../error-messages/compiler-warnings/compiler-warning-level-2-c4302.md)|"*转换*"：从 "*type1*" 到 "*type2*" 的截断|
|编译器警告 C4303|已弃用从 "*type1*" 到 "*type2*" 的 C 样式强制转换，请使用静态 \_ 强制转换， \_ \_ 尝试 \_ 强制转换或动态 \_ 强制转换|
|[编译器警告（等级 1）C4305](../../error-messages/compiler-warnings/compiler-warning-level-1-c4305.md)|"*转换*"：从 "*type1*" 到 "*type2*" 的截断|
|[编译器警告（等级 3）C4306](../../error-messages/compiler-warnings/compiler-warning-level-3-c4306.md)|"*转换*"：从 "*type1*" 转换为 "*type2*" 的大小更大|
|[编译器警告（等级 2）C4307](../../error-messages/compiler-warnings/compiler-warning-level-2-c4307.md)|"*operator*"：整型常量溢出|
|[编译器警告（等级 2）C4308](../../error-messages/compiler-warnings/compiler-warning-level-2-c4308.md)|负整型常量转换为无符号类型|
|[编译器警告（等级 2）C4309](../../error-messages/compiler-warnings/compiler-warning-level-2-c4309.md)|"*转换*"：对常量值的截断|
|[编译器警告（等级 3）C4310](../../error-messages/compiler-warnings/compiler-warning-level-3-c4310.md)|强制转换截断常量值|
|[编译器警告（等级 1）C4311](../../error-messages/compiler-warnings/compiler-warning-level-1-c4311.md)|"*variable*"：从 "*type1*" 到 "*type2*" 的指针截断|
|[编译器警告（等级 1）C4312](../../error-messages/compiler-warnings/compiler-warning-level-1-c4312.md)|"*operation*"：从 "*type1*" 转换为 "*type2*" 的大小更大|
|[编译器警告（等级 1）C4313](../../error-messages/compiler-warnings/compiler-warning-level-1-c4313.md)|"*function*"：格式字符串中的 "*format_specifier*" 与 "*type*" 类型的参数 "*argument_number*" 冲突|
|编译器警告 C4314|杂注参数应为 "32" 或 "64"|
|编译器警告 (等级 4) C4315|"*classname*"：成员 "*member*" 的 "this" 指针可能不是构造函数预期的对齐 "*对齐*"|
|[编译器警告（等级 3）C4316](compiler-warning-level-3-c4316.md)|"*identifier*"：在堆上分配的对象可能不是对齐的 "*对齐*"|
|编译器警告 (等级 1) C4317|"*printf_family*"：没有为格式字符串传递足够的参数|
|编译器警告 C4318|将常量零作为长度传递给 memset|
|[编译器警告（等级 1）C4319](../../error-messages/compiler-warnings/compiler-warning-level-1-c4319.md)|"*operator*"：将 "*type1*" 扩展到更大的 "*type2*" 时为零|
|编译器警告 (等级 1) C4321|自动生成接口 "*interface*" 的 IID|
|编译器警告 (等级 1) C4322|自动生成类 "*class*" 的 CLSID|
|编译器警告 (等级 1) C4323|重新使用类 "*class*" 的已注册 CLSID|
|[编译器警告（等级 4）C4324](../../error-messages/compiler-warnings/compiler-warning-level-4-c4324.md)|"*structname*"：结构已填充，因为 __declspec (对齐 ( # A2 # A3|
|[编译器警告（等级 1）C4325](../../error-messages/compiler-warnings/compiler-warning-level-1-c4325.md)|已忽略标准节 "*section*" 的属性|
|[编译器警告（等级 1）C4326](../../error-messages/compiler-warnings/compiler-warning-level-1-c4326.md)|"*function*" 的返回类型应为 "*type1*"，而不是 "*type2*"|
|编译器警告 C4327|"*赋值*"： LHS 的间接对齐 ( "*alignment1*" ) 大于 RHS ( "*alignment2*" ) |
|编译器警告 C4328|"*function*"：形参*parameter_number* (*parameter_alignment*) 的间接对齐方式大于实际的参数*对齐 (argument_alignment) *|
|[编译器警告（等级 1）C4329](../../error-messages/compiler-warnings/compiler-warning-level-1-c4329.md)|__declspec (对齐 ( # A2 # A3 在枚举上被忽略|
|编译器警告 (等级 1) C4330|已忽略节 "*section*" 的特性 "*attribute*"|
|[编译器警告（等级 1）C4333](../../error-messages/compiler-warnings/compiler-warning-level-1-c4333.md)|"*shift_operator*"：右移量过大，数据丢失|
|[编译器警告（等级 3）C4334](../../error-messages/compiler-warnings/compiler-warning-level-3-c4334.md)|"*shift_operator*"：32位移位的结果被隐式转换为64位 (是否需要64位移位？ ) |
|[编译器警告 C4335](../../error-messages/compiler-warnings/compiler-warning-c4335.md)|检测到 Mac 文件格式：请将源文件转换为 DOS 格式或 UNIX 格式|
|[编译器警告（等级 4）C4336](../../error-messages/compiler-warnings/compiler-warning-level-4-c4336.md)|导入 "*library2*" 之前，导入交叉引用类型库 "*library1*"|
|[编译器警告（等级 4）C4337](../../error-messages/compiler-warnings/compiler-warning-level-4-c4337.md)|正在自动导入 "*library2*" 中的交叉引用类型库 "*library1*"|
|编译器警告 (等级 4) C4338|#pragma *指令*：使用标准节 "*section*"|
|[编译器警告（等级 4）C4339](../../error-messages/compiler-warnings/compiler-warning-level-4-c4339.md)|"*type*"：在 "WINRT&#124;CLR" 元数据中检测到使用了未定义的类型-使用此类型可能导致运行时异常|
|[编译器警告（等级 1）C4340](../../error-messages/compiler-warnings/compiler-warning-level-1-c4340.md)|"*value*"：值从正值换为负值|
|[编译器警告（等级 1）C4342](../../error-messages/compiler-warnings/compiler-warning-level-1-c4342.md)|行为更改：调用了 "*function*"，但在以前的版本中调用了成员运算符|
|[编译器警告（等级 4）C4343](compiler-warning-level-4-c4343.md)|#pragma optimize("g",off) 重写 /Og 选项|
|[编译器警告（等级 1）C4344](../../error-messages/compiler-warnings/compiler-warning-level-1-c4344.md)|行为更改：使用显式模板参数导致调用 "*function*"|
|[编译器警告（等级 1）C4346](../../error-messages/compiler-warnings/compiler-warning-level-1-c4346.md)|"*name*"：依赖名称不是类型|
|[编译器警告（等级 1）C4348](../../error-messages/compiler-warnings/compiler-warning-level-1-c4348.md)|"*type*"：重定义默认参数：参数 "*parameter_number*"|
|[编译器警告（等级 1）C4350](../../error-messages/compiler-warnings/compiler-warning-level-1-c4350.md)|行为更改：调用了 "*member1*" 而不是 "*member2*"|
|编译器警告 (等级 1) C4352|"*identifier*"：已定义内部函数|
|[编译器警告（等级 1）C4353](../../error-messages/compiler-warnings/compiler-warning-level-1-c4353.md)|使用了非标准扩展：常量0作为函数表达式。  改用 "__noop" 函数内部函数|
|[编译器警告 C4355](../../error-messages/compiler-warnings/compiler-warning-c4355.md)编译器警告 (等级1和等级 4) C4355|"this"：用于基成员初始值设定项列表|
|[编译器警告（等级 2）C4356](../../error-messages/compiler-warnings/compiler-warning-level-2-c4356.md)|"*member*"：静态数据成员不能通过派生类初始化|
|[编译器警告（等级 3）C4357](../../error-messages/compiler-warnings/compiler-warning-level-3-c4357.md)|生成 "*function*" 时，已忽略委托 "*delegate*" 的形参表中找到的参数数组参数|
|[编译器警告（等级 1）C4358](../../error-messages/compiler-warnings/compiler-warning-level-1-c4358.md)|"*operator*"：组合委托的返回类型不是 "void";返回值未定义|
|[编译器警告（等级 3）C4359](../../error-messages/compiler-warnings/compiler-warning-level-3-c4359.md)|"*type*"：对齐说明符小于实际对齐方式 ( "*对齐*" ) ，将被忽略。|
|编译器警告 (等级 2) C4362|"*type*"： CLR 不支持超过8个字节的对齐|
|[编译器警告（等级 1）C4364](../../error-messages/compiler-warnings/compiler-warning-level-1-c4364.md)|之前在 "*location*" ( "*line_number*" ) 中显示的程序集 "*assembly*" 的 #using，但不 \_ 应用于 friend 属性; 否则为 \_ friend|
|[编译器警告（等级 4）C4365](../../error-messages/compiler-warnings/compiler-warning-level-4-c4365.md)|"*expression*"：从 "*type1*" 转换到 "*type2*"，有符号/无符号不匹配|
|[编译器警告（等级 4）C4366](../../error-messages/compiler-warnings/compiler-warning-level-4-c4366.md)|一元运算符 "*operator*" 运算符的结果可能是未对齐的|
|编译器警告 (等级 3) C4367|从 "*type1*" 到 "*type2*" 的转换可能会导致数据类型不对齐异常|
|[编译器警告 (错误) C4368](../../error-messages/compiler-warnings/compiler-warning-c4368.md)|无法将 "*member*" 定义为托管 "*type*" 的成员：不支持混合类型|
|[编译器警告（等级 1）C4369](../../error-messages/compiler-warnings/compiler-warning-level-1-c4369.md)|"*枚举器*"：枚举器值 "*value*" 不能表示为 "*type*"，值为 "*new_value*"|
|编译器警告 C4370|"*classname*"：由于更好的封装，类的布局与早期版本的编译器发生了变化|
|[编译器警告（等级 3）C4371](../../error-messages/compiler-warnings/c4371.md)|"*classname*"：类的布局可能与早期版本的编译器发生了变化，因为更好地封装了成员 "*member*"|
|[编译器警告（等级 3）C4373](compiler-warning-level-3-c4373.md)|"*derived_class*：：*function*"：虚函数重写 "*base_class*：：*function*"，当参数只在 const/volatile 限定符上有差异时，早期版本的编译器不会重写|
|[编译器警告（等级 1）C4374](../../error-messages/compiler-warnings/compiler-warning-level-1-c4374.md)|"*function1*"：接口方法不能由非虚方法 "*function2*" 实现|
|[编译器警告（等级 1）C4375](../../error-messages/compiler-warnings/compiler-warning-level-1-c4375.md)|非公共方法 "*method2*" 不重写 "*method2*"|
|[编译器警告（等级 1）C4376](../../error-messages/compiler-warnings/compiler-warning-level-1-c4376.md)|不再支持访问说明符 "*old_specifier*："：请改用 "*new_specifier*："|
|[编译器警告（等级 1）C4377](../../error-messages/compiler-warnings/compiler-warning-level-1-c4377.md)|本机类型默认为私有类型;-d1PrivateNativeTypes 已弃用|
|[编译器警告（等级 1）C4378](../../error-messages/compiler-warnings/compiler-warning-level-1-c4378.md)|必须获得函数指针才能运行初始值设定项;请考虑 System：： ModuleHandle：： ResolveMethodHandle|
|[编译器警告（等级 1）C4379](../../error-messages/compiler-warnings/compiler-warning-level-1-c4379.md)|此编译器不支持公共语言运行时的版本 "*version_number*"。 使用此版本可能会导致意外的结果|
|编译器警告 (等级1，错误) C4380|"*class*"：不能弃用默认构造函数|
|[编译器警告（等级 1）C4381](../../error-messages/compiler-warnings/compiler-warning-level-1-c4381.md)|"*function1*"：非公共方法 "*function2*" 将不实现接口方法|
|[编译器警告（等级 1）C4382](../../error-messages/compiler-warnings/compiler-warning-level-1-c4382.md)|引发 "*type*"：包含 __clrcall 析构函数或复制构造函数的类型只能在/clr： pure 模块中捕获|
|[编译器警告（等级 1）C4383](../../error-messages/compiler-warnings/compiler-warning-level-1-c4383.md)|"*instance_dereference_operator*"：当存在用户定义的 "*instance_dereference_operator*" 运算符时，取消引用句柄的含义可能会更改;将运算符编写为静态函数，以显式了解操作数|
|[编译器警告（等级 1）C4384](../../error-messages/compiler-warnings/compiler-warning-level-1-c4384.md)|#pragma "make_public" 只能在全局范围内使用|
|编译器警告 (等级 3) C4387|"*替代*"：已被考虑|
|[编译器警告 (等级 4) C4388](./c4388.md)) |"*expression*"：有符号/无符号不匹配|
|[编译器警告（等级 4）C4389](../../error-messages/compiler-warnings/compiler-warning-level-4-c4389.md)|"*operator*"：有符号/无符号不匹配|
|[编译器警告（等级 3）C4390](../../error-messages/compiler-warnings/compiler-warning-level-3-c4390.md)|";"：找到空的受控语句;这是不是吗？|
|[编译器警告（等级 1）C4391](../../error-messages/compiler-warnings/compiler-warning-level-1-c4391.md)|"*function_signature*"：不正确的内部函数返回类型，应为 "*type*"|
|[编译器警告（等级 1）C4392](../../error-messages/compiler-warnings/compiler-warning-level-1-c4392.md)|"*function_signature*"：内部函数的参数数目不正确，应为 "*argument_count*" 参数|
|[编译器警告（等级 1）C4393](../../error-messages/compiler-warnings/compiler-warning-level-1-c4393.md)|"*variable*"： const 对 "*literal*" 数据成员不起作用;掉|
|[编译器警告 C4394](../../error-messages/compiler-warnings/compiler-warning-c4394.md)|"*function*"：不应将每个 appdomain 符号标记 __declspec ( "dllexport" ) |
|[编译器警告（等级 1）C4395](../../error-messages/compiler-warnings/compiler-warning-level-1-c4395.md)|"*function*"：将对 initonly 数据成员 "*member*" 的副本调用成员函数|
|[编译器警告（等级 2）C4396](compiler-warning-level-2-c4396.md)|"*function*"：友元声明引用函数模板的专用化时，无法使用内联说明符|
|[编译器警告（等级 1）C4397](../../error-messages/compiler-warnings/compiler-warning-level-1-c4397.md)|已忽略 DefaultCharSetAttribute|
|[编译器警告（等级 3）C4398](../../error-messages/compiler-warnings/compiler-warning-level-3-c4398.md)|"*variable*"：每进程全局对象可能无法与多个 appdomain 一起正常工作;请考虑使用 __declspec (appdomain) |
|[编译器警告（等级 1）C4399](../../error-messages/compiler-warnings/compiler-warning-level-1-c4399.md)|"*symbol*"：在用/clr： pure 编译时，不应将每进程符号标记 __declspec ( "dllimport" ) |

## <a name="see-also"></a>另请参阅

[C/c + + 编译器和生成工具错误和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[编译器警告 C4000 - C5999](compiler-warnings-c4000-c5999.md)
